<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AIÊô∫ËÉΩÂä©Êâã</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: transparent;
            min-height: 100vh;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        .ai-chat-module {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: transparent;
        }

        .ai-chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: transparent;
        }

        .chat-message {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            animation: messageSlide 0.3s ease;
            position: relative;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .message-avatar.ai {
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        .message-avatar.user {
            background: linear-gradient(135deg, #4A90E2, #2563eb);
            color: white;
        }

        .message-content {
            max-width: 280px;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .message-content.ai {
            background: rgba(249, 250, 251, 0.8);
            color: #374151;
            border-top-left-radius: 6px;
        }

        .message-content.user {
            background: linear-gradient(135deg, #4A90E2, #2563eb);
            color: white;
            border-top-right-radius: 6px;
        }

        .message-time {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
            text-align: center;
        }

        .message-actions {
            display: none;
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            gap: 4px;
        }

        .chat-message:hover .message-actions {
            display: flex;
        }

        .action-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(249, 250, 251, 0.8);
            border-radius: 18px;
            border-top-left-radius: 6px;
            max-width: 280px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: #9ca3af;
            border-radius: 50%;
            animation: typingDot 1.4s infinite;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .typing-text {
            font-size: 12px;
            color: #6b7280;
        }

        .message-complete {
            color: #10b981;
            font-size: 12px;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }

        .message-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 12px;
            padding: 12px 16px;
            margin: 10px 0;
            max-width: 280px;
        }

        .error-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #dc2626;
        }

        .retry-btn {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
            transition: all 0.2s ease;
        }

        .retry-btn:hover {
            background: #b91c1c;
        }

        .ai-input-area {
            padding: 16px 20px 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }

        .quick-replies {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .quick-reply {
            padding: 6px 12px;
            background: rgba(255, 20, 147, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.2);
            border-radius: 16px;
            font-size: 12px;
            color: #FF1493;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0;
            transform: translateY(10px);
            animation: quickReplySlide 0.3s ease forwards;
        }

        .quick-reply:nth-child(1) { animation-delay: 0.1s; }
        .quick-reply:nth-child(2) { animation-delay: 0.2s; }
        .quick-reply:nth-child(3) { animation-delay: 0.3s; }
        .quick-reply:nth-child(4) { animation-delay: 0.4s; }

        .quick-reply:hover {
            background: rgba(255, 20, 147, 0.2);
            transform: translateY(-1px);
        }

        .input-container {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .ai-input {
            flex: 1;
            min-height: 40px;
            max-height: 120px;
            padding: 10px 16px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: all 0.2s ease;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.9);
        }

        .ai-input:focus {
            border-color: #FF1493;
            box-shadow: 0 0 0 3px rgba(255, 20, 147, 0.1);
        }

        .send-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: white;
            font-size: 16px;
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 20, 147, 0.4);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .api-settings {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 16px;
            width: 280px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            transform: scale(0.95) translateY(-10px);
            opacity: 0;
            transition: all 0.2s ease;
            pointer-events: none;
        }

        .api-settings.show {
            transform: scale(1) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .api-settings h4 {
            margin-bottom: 12px;
            color: #2E3A59;
            font-size: 16px;
        }

        .api-settings label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #4b5563;
            font-weight: 500;
        }

        .api-settings input,
        .api-settings select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            transition: all 0.2s ease;
        }

        .api-settings input:focus,
        .api-settings select:focus {
            outline: none;
            border-color: #FF1493;
            box-shadow: 0 0 0 2px rgba(255, 20, 147, 0.1);
        }

        .api-settings button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .api-settings button:hover {
            background: linear-gradient(135deg, #FF1493, #DC143C);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 20, 147, 0.3);
        }

        .settings-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.05);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: #6b7280;
            font-size: 14px;
            z-index: 1001;
        }

        .settings-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 10000;
            animation: slideInNotification 0.3s ease;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 300px;
        }

        .notification.success { background: #10b981; color: white; }
        .notification.error { background: #ef4444; color: white; }
        .notification.warning { background: #f59e0b; color: white; }
        .notification.info { background: #3b82f6; color: white; }

        /* Âä®ÁîªÂÆö‰πâ */
        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes quickReplySlide {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes typingDot {
            0%, 60%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            30% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInNotification {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOutNotification {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* ÂìçÂ∫îÂºèÈÄÇÈÖç */
        @media (max-width: 400px) {
            .ai-chat-area {
                padding: 15px;
            }

            .ai-input-area {
                padding: 16px 15px 20px;
            }

            .message-content {
                max-width: 240px;
            }

            .api-settings {
                right: 10px;
                left: 10px;
                width: auto;
            }
        }
    </style>
</head>
<body class="embedded">
    <!-- APIËÆæÁΩÆÊåâÈíÆ -->
    <button class="settings-btn" onclick="app.uiManager.toggleAPISettings()" title="APIËÆæÁΩÆ">
        <i class="fas fa-cog"></i>
    </button>

    <!-- APIËÆæÁΩÆÈù¢Êùø -->
    <div class="api-settings" id="apiSettings">
        <h4>API ÈÖçÁΩÆ</h4>
        <label for="apiKey">API Key</label>
        <input type="password" id="apiKey" placeholder="ËØ∑ËæìÂÖ•ÊÇ®ÁöÑAPI Key">

        <label for="modelSelect">Ê®°ÂûãÈÄâÊã©</label>
        <select id="modelSelect">
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            <option value="gpt-4">GPT-4</option>
            <option value="gpt-4-turbo">GPT-4 Turbo</option>
            <option value="llama2">Llama 2</option>
            <option value="claude-3">Claude 3</option>
        </select>

        <label for="maxTokens">ÊúÄÂ§ß‰ª§ÁâåÊï∞</label>
        <input type="number" id="maxTokens" value="2000" min="100" max="4000">

        <label for="temperature">ÂàõÈÄ†ÊÄß (0-1)</label>
        <input type="number" id="temperature" value="0.7" min="0" max="1" step="0.1">

        <button onclick="app.configManager.saveSettings()">‰øùÂ≠òËÆæÁΩÆ</button>
    </div>

    <div class="ai-chat-module">
        <div class="ai-chat-area" id="aiChatArea">
            <div class="chat-message">
                <div class="message-avatar ai">üê∑</div>
                <div>
                    <div class="message-content ai">
                        ÊÇ®Â•ΩÔºÅÊàëÊòØÁ•ûÂÜúÊôìÈóÆÔºåÊÇ®ÁöÑ‰∏ìÂ±ûÊô∫ËÉΩÂÜúÁâßÂä©ÊâãÔºÅüê∑‚ú®<br><br>
                        ËØ∑ÂÖàÂú®ËÆæÁΩÆ‰∏≠ÈÖçÁΩÆAPI KeyÔºåÁÑ∂ÂêéÊàëÂ∞±ËÉΩ‰∏∫ÊÇ®Êèê‰æõ‰∏ì‰∏öÁöÑÂÜúÁâß‰∏öÂí®ËØ¢ÊúçÂä°‰∫ÜÔºÅ
                    </div>
                    <div class="message-time">ÂàöÂàö</div>
                </div>
            </div>
        </div>

        <div class="ai-input-area">
            <div class="quick-replies" id="quickReplies">
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('Áîü‰∫ßÁÆ°ÁêÜÁ≥ªÁªüÊÄé‰πà‰ΩøÁî®Ôºü')">Áîü‰∫ßÁÆ°ÁêÜ</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('Êô∫ÊÖßÂÖªÊÆñÊúâÂì™‰∫õÂäüËÉΩÔºü')">Êô∫ÊÖßÂÖªÊÆñ</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('Â¶Ç‰ΩïËøõË°åÊï∞ÊçÆÂàÜÊûêÔºü')">Êï∞ÊçÆÂàÜÊûê</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('Á≥ªÁªüÊìç‰ΩúÂ∏ÆÂä©')">Á≥ªÁªüÂ∏ÆÂä©</div>
            </div>
            <div class="input-container">
                <textarea class="ai-input"
                          id="aiInput"
                          placeholder="ËæìÂÖ•ÊÇ®ÁöÑÈóÆÈ¢ò..."
                          rows="1"></textarea>
                <button class="send-button" id="sendButton">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== Ê†∏ÂøÉÈÖçÁΩÆÁÆ°ÁêÜÂô® =====
        class ConfigManager {
            constructor() {
                this.config = {
                    baseURL: 'http://47.236.87.251:3000/api',
                    apiKey: '',
                    model: 'snDr-1.0-turbo',
                    maxTokens: 2000,
                    temperature: 0.7
                };
                this.observers = [];
                this.loadSettings();
            }

            addObserver(observer) {
                this.observers.push(observer);
            }

            removeObserver(observer) {
                this.observers = this.observers.filter(obs => obs !== observer);
            }

            notifyObservers(change) {
                this.observers.forEach(observer => {
                    if (typeof observer.onConfigChange === 'function') {
                        observer.onConfigChange(change);
                    }
                });
            }

            updateConfig(updates) {
                const oldConfig = { ...this.config };
                this.config = { ...this.config, ...updates };
                
                this.notifyObservers({
                    type: 'config_updated',
                    oldConfig,
                    newConfig: this.config,
                    changes: updates
                });
            }

            validateApiKey(apiKey) {
                if (!apiKey || apiKey.length < 10) {
                    throw new Error('API KeyÈïøÂ∫¶ËøáÁü≠ÔºåËØ∑Ê£ÄÊü•ÊòØÂê¶ÂÆåÊï¥');
                }
                
                // Ê£ÄÊü•ÈùûASCIIÂ≠óÁ¨¶
                const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '');
                if (apiKey !== cleanApiKey) {
                    throw new Error('API KeyÂåÖÂê´Êó†ÊïàÂ≠óÁ¨¶ÔºåËØ∑‰ΩøÁî®Á∫ØËã±ÊñáÂ≠óÁ¨¶');
                }
                
                return cleanApiKey;
            }

            saveSettings() {
                try {
                    const apiKey = document.getElementById('apiKey').value.trim();
                    const model = document.getElementById('modelSelect').value;
                    const maxTokens = parseInt(document.getElementById('maxTokens').value);
                    const temperature = parseFloat(document.getElementById('temperature').value);

                    if (apiKey) {
                        this.validateApiKey(apiKey);
                    }

                    this.updateConfig({
                        apiKey,
                        model,
                        maxTokens,
                        temperature
                    });

                    localStorage.setItem('aiConfig', JSON.stringify(this.config));
                    
                    app.uiManager.closeAPISettings();
                    app.notificationManager.show(
                        apiKey ? 'APIËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºÅÂèØ‰ª•ÂºÄÂßãÂØπËØù‰∫Ü' : 'APIËÆæÁΩÆÂ∑≤‰øùÂ≠òÔºå‰ΩÜÈúÄË¶ÅÈÖçÁΩÆÊúâÊïàÁöÑAPI Key',
                        apiKey ? 'success' : 'warning'
                    );
                } catch (error) {
                    app.notificationManager.show(error.message, 'error');
                }
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('aiConfig');
                    if (saved) {
                        const config = JSON.parse(saved);
                        this.config = { ...this.config, ...config };
                        this.updateUIWithConfig();
                    }
                } catch (error) {
                    console.error('Âä†ËΩΩAPIËÆæÁΩÆÂ§±Ë¥•:', error);
                }
            }

            updateUIWithConfig() {
                const elements = {
                    'apiKey': this.config.apiKey,
                    'modelSelect': this.config.model,
                    'maxTokens': this.config.maxTokens,
                    'temperature': this.config.temperature
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.value = value;
                    }
                });
            }

            getConfig() {
                return { ...this.config };
            }
        }

        // ===== APIÂÆ¢Êà∑Á´ØÁÆ°ÁêÜÂô® =====
        class APIClient {
            constructor(configManager) {
                this.configManager = configManager;
                this.currentController = null;
                this.retryCount = 0;
                this.maxRetries = 3;
                this.baseDelay = 1000; // Âü∫Á°ÄÂª∂Ëøü1Áßí
            }

            async sendMessage(messages, onChunk, onComplete, onError) {
                const config = this.configManager.getConfig();
                
                if (!config.apiKey) {
                    throw new Error('ËØ∑ÂÖàÈÖçÁΩÆAPI Key');
                }

                this.currentController = new AbortController();
                this.retryCount = 0;

                try {
                    await this._sendWithRetry(messages, onChunk, onComplete, onError);
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        onError(error);
                    }
                }
            }

            async _sendWithRetry(messages, onChunk, onComplete, onError) {
                const config = this.configManager.getConfig();
                
                try {
                    const response = await this._makeRequest(messages, config);
                    await this._handleStreamResponse(response, onChunk, onComplete);
                } catch (error) {
                    if (this.shouldRetry(error) && this.retryCount < this.maxRetries) {
                        this.retryCount++;
                        const delay = this.baseDelay * Math.pow(2, this.retryCount - 1); // ÊåáÊï∞ÈÄÄÈÅø
                        
                        app.notificationManager.show(
                            `ËØ∑Ê±ÇÂ§±Ë¥•Ôºå${delay / 1000}ÁßíÂêéÈáçËØï (${this.retryCount}/${this.maxRetries})`,
                            'warning'
                        );
                        
                        await this._delay(delay);
                        return this._sendWithRetry(messages, onChunk, onComplete, onError);
                    }
                    throw error;
                }
            }

            async _makeRequest(messages, config) {
                const requestHeaders = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${config.apiKey}`
                };

                const requestBody = {
                    model: '-',
                    messages,
                    max_tokens: config.maxTokens,
                    temperature: config.temperature,
                    stream: true
                };

                const response = await fetch(`${config.baseURL}/chat/completions`, {
                    method: 'POST',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody),
                    signal: this.currentController.signal
                });

                if (!response.ok) {
                    throw this._createErrorFromResponse(response);
                }

                return response;
            }

            async _handleStreamResponse(response, onChunk, onComplete) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6).trim();
                            if (data === '[DONE]') {
                                onComplete(fullResponse);
                                return;
                            }

                            if (data) {
                                try {
                                    const parsed = JSON.parse(data);
                                    const content = parsed.choices?.[0]?.delta?.content;

                                    if (content) {
                                        fullResponse += content;
                                        onChunk(content);
                                    }
                                } catch (parseError) {
                                    console.warn('Ëß£ÊûêSSEÊï∞ÊçÆÂ§±Ë¥•:', parseError);
                                    continue;
                                }
                            }
                        }
                    }
                }

                onComplete(fullResponse);
            }

            _createErrorFromResponse(response) {
                let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                
                switch (response.status) {
                    case 401:
                        errorMessage = 'ËÆ§ËØÅÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•API KeyÊòØÂê¶Ê≠£Á°Æ';
                        break;
                    case 403:
                        errorMessage = 'ËÆøÈóÆË¢´ÊãíÁªùÔºåAPI KeyÂèØËÉΩÊ≤°ÊúâÊùÉÈôê';
                        break;
                    case 404:
                        errorMessage = 'ÊúçÂä°Âô®Á´ØÁÇπ‰∏çÂ≠òÂú®ÔºåËØ∑Ê£ÄÊü•ÊúçÂä°Âô®Âú∞ÂùÄ';
                        break;
                    case 429:
                        errorMessage = 'ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅÔºåËØ∑Á®çÂêéÂÜçËØï';
                        break;
                    case 500:
                        errorMessage = 'ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï';
                        break;
                }

                return new Error(errorMessage);
            }

            shouldRetry(error) {
                if (error.name === 'AbortError') return false;
                
                const retryableErrors = [500, 502, 503, 504, 429];
                const statusMatch = error.message.match(/HTTP (\d+):/);
                
                if (statusMatch) {
                    const status = parseInt(statusMatch[1]);
                    return retryableErrors.includes(status);
                }
                
                return error.message.includes('ÁΩëÁªú') || 
               error.message.includes('timeout') ||
               error.message.includes('Failed to fetch');
            }

            _delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            abort() {
                if (this.currentController) {
                    this.currentController.abort();
                    this.currentController = null;
                }
            }
        }

        // ===== Ê∂àÊÅØÁÆ°ÁêÜÂô® =====
        class MessageManager {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.messages = [];
                this.maxHistory = 10;
                this.contextWindow = 4000;
                this.messageTemplates = this._initializeTemplates();
                this.observers = [];
            }

            addObserver(observer) {
                this.observers.push(observer);
            }

            notifyObservers(event) {
                this.observers.forEach(observer => {
                    if (typeof observer.onMessageEvent === 'function') {
                        observer.onMessageEvent(event);
                    }
                });
            }

            addMessage(role, content) {
                const message = {
                    id: this._generateId(),
                    role,
                    content,
                    timestamp: new Date(),
                    tokens: this._estimateTokens(content)
                };

                this.messages.push(message);
                this._trimContext();
                
                this.notifyObservers({
                    type: 'message_added',
                    message
                });

                return message;
            }

            async sendMessage(content) {
                if (!content.trim() || app.isStreaming) return;

                const userMessage = this.addMessage('user', content);
                app.uiManager.addMessageToUI(userMessage);
                
                app.isStreaming = true;
                app.uiManager.setStreamingState(true);

                const typingIndicator = app.uiManager.showTypingIndicator();

                try {
                    const contextMessages = this._getContextForAPI();
                    let fullResponse = '';

                    await this.apiClient.sendMessage(
                        contextMessages,
                        (chunk) => {
                            if (!app.currentStreamHandler) {
                                app.uiManager.hideTypingIndicator();
                                const messageElement = app.uiManager.createStreamingMessage();
                                app.currentStreamHandler = new StreamHandler(messageElement);
                            }
                            app.currentStreamHandler.addChunk(chunk);
                        },
                        (response) => {
                            fullResponse = response;
                            const aiMessage = this.addMessage('assistant', response);
                            
                            if (app.currentStreamHandler) {
                                app.currentStreamHandler.finishTyping();
                                app.currentStreamHandler = null;
                            }
                        },
                        (error) => {
                            app.uiManager.hideTypingIndicator();
                            app.uiManager.showErrorMessage(error.message, () => {
                                this.retryLastMessage();
                            });
                        }
                    );

                } catch (error) {
                    app.uiManager.hideTypingIndicator();
                    app.uiManager.showErrorMessage(error.message, () => {
                        this.retryLastMessage();
                    });
                } finally {
                    app.isStreaming = false;
                    app.uiManager.setStreamingState(false);
                }
            }

            sendQuickReply(message) {
                app.uiManager.setInputValue(message);
                this.sendMessage(message);
            }

            retryLastMessage() {
                const errorMessages = document.querySelectorAll('.error-message-container');
                errorMessages.forEach(msg => msg.remove());

                const lastUserMessage = this.messages[this.messages.length - 1];
                if (lastUserMessage && lastUserMessage.role === 'user') {
                    this.messages.pop();
                    this.sendMessage(lastUserMessage.content);
                }
            }

            copyMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"] .message-content`);
                if (messageElement) {
                    const text = messageElement.textContent || messageElement.innerText;
                    navigator.clipboard.writeText(text).then(() => {
                        app.notificationManager.show('Ê∂àÊÅØÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', 'success');
                    }).catch(() => {
                        app.notificationManager.show('Â§çÂà∂Â§±Ë¥•', 'error');
                    });
                }
            }

            regenerateMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    // ÁßªÈô§ÂêéÁª≠ÁöÑAIÊ∂àÊÅØ
                    let current = messageElement.nextElementSibling;
                    while (current) {
                        const next = current.nextElementSibling;
                        if (current.classList.contains('chat-message') && 
                            !current.classList.contains('user')) {
                            current.remove();
                        }
                        current = next;
                    }
                    
                    messageElement.remove();
                    
                    // ‰ªéÊ∂àÊÅØÂéÜÂè≤‰∏≠ÁßªÈô§ÂØπÂ∫îÁöÑÊ∂àÊÅØ
                    if (this.messages.length > 0) {
                        this.messages = this.messages.slice(0, -1);
                    }
                    
                    const lastUserMessage = this.messages[this.messages.length - 1];
                    if (lastUserMessage && lastUserMessage.role === 'user') {
                        this.sendMessage(lastUserMessage.content);
                    }
                }
            }

            likeMessage(messageId) {
                const likeBtn = document.querySelector(`[data-message-id="${messageId}"] .action-btn[onclick*="likeMessage"]`);
                if (likeBtn) {
                    likeBtn.style.color = '#10b981';
                    likeBtn.innerHTML = '<i class="fas fa-thumbs-up"></i>';
                    app.notificationManager.show('ÊÑüË∞¢ÊÇ®ÁöÑÂèçÈ¶àÔºÅ', 'success');
                    this._recordMessageFeedback(messageId, 'like');
                }
            }

            searchMessages(query) {
                const results = [];
                for (const message of this.messages) {
                    if (message.content.toLowerCase().includes(query.toLowerCase())) {
                        results.push(message);
                    }
                }
                return results.sort((a, b) => b.timestamp - a.timestamp);
            }

            exportMessages(format = 'json') {
                const data = {
                    messages: this.messages,
                    exportTime: new Date().toISOString(),
                    totalMessages: this.messages.length
                };

                let content, filename, mimeType;

                switch (format) {
                    case 'json':
                        content = JSON.stringify(data, null, 2);
                        filename = `chat_export_${new Date().toISOString().split('T')[0]}.json`;
                        mimeType = 'application/json';
                        break;
                    case 'txt':
                        content = this.messages.map(msg => 
                            `[${msg.timestamp.toLocaleString()}] ${msg.role}: ${msg.content}`
                        ).join('\n\n');
                        filename = `chat_export_${new Date().toISOString().split('T')[0]}.txt`;
                        mimeType = 'text/plain';
                        break;
                    default:
                        throw new Error('‰∏çÊîØÊåÅÁöÑÂØºÂá∫Ê†ºÂºè');
                }

                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearMessages() {
                this.messages = [];
                const chatArea = document.getElementById('aiChatArea');
                if (chatArea) {
                    // Âè™‰øùÁïôÊ¨¢ËøéÊ∂àÊÅØ
                    const welcomeMessage = chatArea.querySelector('.chat-message');
                    chatArea.innerHTML = '';
                    if (welcomeMessage) {
                        chatArea.appendChild(welcomeMessage);
                    }
                }
                
                this.notifyObservers({
                    type: 'messages_cleared'
                });
            }

            _trimContext() {
                let totalTokens = this.messages.reduce((sum, msg) => sum + msg.tokens, 0);
                
                while ((totalTokens > this.contextWindow || this.messages.length > this.maxHistory * 2) 
                       && this.messages.length > 2) {
                    const removed = this.messages.shift();
                    totalTokens -= removed.tokens;
                }
            }

            _getContextForAPI() {
                return [
                    {
                        role: 'system',
                        content: '‰Ω†ÊòØÁ•ûÂÜúÈõÜÂõ¢ÁöÑÊô∫ËÉΩÂÜúÁâßÂä©Êâã"Á•ûÂÜúÊôìÈóÆ"Ôºå‰∏ìÈó®‰∏∫Áî®Êà∑Êèê‰æõÂÜúÁâß‰∏öÁîü‰∫ß„ÄÅÁÆ°ÁêÜ„ÄÅÊäÄÊúØÁ≠âÊñπÈù¢ÁöÑ‰∏ì‰∏öÂí®ËØ¢ÂíåÁ≥ªÁªüÊìç‰ΩúÊåáÂØº„ÄÇËØ∑Áî®‰∏≠ÊñáÂõûÁ≠îÔºåËØ≠Ê∞îË¶ÅÂèãÂ•Ω‰∏ì‰∏ö„ÄÇ'
                    },
                    ...this.messages.map(msg => ({
                        role: msg.role,
                        content: msg.content
                    }))
                ];
            }

            _estimateTokens(text) {
                return Math.ceil(text.length / 1.5);
            }

            _generateId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            _initializeTemplates() {
                return {
                    farming: [
                        'Â¶Ç‰ΩïÊü•ÁúãÁîü‰∫ßÊä•Ë°®Ôºü',
                        'Áîü‰∫ßËÆ°ÂàíÊÄé‰πàÂà∂ÂÆöÔºü',
                        'Â¶Ç‰ΩïËÆ∞ÂΩïÁîü‰∫ßÊï∞ÊçÆÔºü',
                        'ÂºÇÂ∏∏ÊÉÖÂÜµÂ¶Ç‰ΩïÂ§ÑÁêÜÔºü'
                    ],
                    breeding: [
                        'Â¶Ç‰ΩïÁõëÊéßÂä®Áâ©ÂÅ•Â∫∑Ôºü',
                        'ÁéØÂ¢ÉÂèÇÊï∞ËÆæÁΩÆÊåáÂçó',
                        'È•≤ÊñôÈÖçÊØîÂª∫ËÆÆ',
                        'Áñ´ËãóÊé•ÁßçÊèêÈÜí'
                    ],
                    data: [
                        'Â¶Ç‰ΩïÂØºÂá∫Êï∞ÊçÆÔºü',
                        'Êä•Ë°®ÁîüÊàêÊ≠•È™§',
                        'Êï∞ÊçÆÂºÇÂ∏∏Â§ÑÁêÜ',
                        'ÁªüËÆ°ÂõæË°®ËØ¥Êòé'
                    ]
                };
            }

            _recordMessageFeedback(messageId, type) {
                const feedback = {
                    messageId,
                    type,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                
                const existingFeedback = JSON.parse(localStorage.getItem('messageFeedback') || '[]');
                existingFeedback.push(feedback);
                localStorage.setItem('messageFeedback', JSON.stringify(existingFeedback));
            }
        }

        // ===== ÊµÅÂºèÂ§ÑÁêÜÂô® =====
        class StreamHandler {
            constructor(messageElement) {
                this.messageElement = messageElement;
                this.displayedText = '';
                this.pendingText = '';
                this.isTyping = false;
                this.typeSpeed = 20;
                this.messageId = this._generateId();
                this.recursionDepth = 0;
                this.maxRecursionDepth = 1000; // Safety limit
            }
            
            addChunk(chunk) {
                this.pendingText += chunk;
                if (!this.isTyping) {
                    this.startTypingEffect();
                }
            }
            
            startTypingEffect() {
                this.isTyping = true;
                this.recursionDepth = 0; // Reset recursion counter
                this._typeNextChar();
            }
            
            _typeNextChar() {
                // Safety check to prevent infinite recursion
                if (this.recursionDepth > this.maxRecursionDepth) {
                    console.error('StreamHandler: Maximum recursion depth exceeded, stopping typing effect');
                    this.isTyping = false;
                    this.finishTyping();
                    return;
                }
                
                if (this.pendingText.length === 0) {
                    this.isTyping = false;
                    this.recursionDepth = 0; // Reset counter
                    return;
                }
                
                this.recursionDepth++;
                
                const charsToAdd = Math.min(2, this.pendingText.length);
                const chars = this.pendingText.slice(0, charsToAdd);
                this.pendingText = this.pendingText.slice(charsToAdd);
                
                this.displayedText += chars;
                this.messageElement.innerHTML = app.uiManager.formatMessage(this.displayedText);
                
                app.uiManager.scrollToBottom();
                
                // Use requestAnimationFrame instead of setTimeout to prevent stack overflow
                // and ensure proper timing with browser rendering
                if (this.isTyping) {
                    requestAnimationFrame(() => {
                        setTimeout(() => {
                            if (this.isTyping) {
                                this._typeNextChar();
                            }
                        }, Math.max(this.typeSpeed, 16)); // Minimum 16ms (60fps)
                    });
                }
            }
            
            finishTyping() {
                this.isTyping = false;
                this.recursionDepth = 0; // Reset recursion counter
                
                if (this.pendingText.length > 0) {
                    this.displayedText += this.pendingText;
                    this.pendingText = '';
                    this.messageElement.innerHTML = app.uiManager.formatMessage(this.displayedText);
                    app.uiManager.scrollToBottom();
                }
                this._onTypingComplete();
            }
            
            _onTypingComplete() {
                this._addMessageActions();
                this._addCompletionIndicator();
                this._updateQuickReplies();
            }
            
            _addMessageActions() {
                const messageContainer = this.messageElement.closest('.chat-message');
                if (messageContainer && !messageContainer.querySelector('.message-actions')) {
                    const actions = document.createElement('div');
                    actions.className = 'message-actions';
                    actions.innerHTML = `
                        <button class="action-btn" title="Â§çÂà∂Ê∂àÊÅØ" onclick="app.messageManager.copyMessage('${this.messageId}')">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="action-btn" title="ÈáçÊñ∞ÁîüÊàê" onclick="app.messageManager.regenerateMessage('${this.messageId}')">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button class="action-btn" title="ÁÇπËµû" onclick="app.messageManager.likeMessage('${this.messageId}')">
                            <i class="fas fa-thumbs-up"></i>
                        </button>
                    `;
                    messageContainer.appendChild(actions);
                    messageContainer.setAttribute('data-message-id', this.messageId);
                }
            }
            
            _addCompletionIndicator() {
                if (!this.messageElement.querySelector('.message-complete')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'message-complete';
                    indicator.innerHTML = ' ‚úì';
                    this.messageElement.appendChild(indicator);
                }
            }
            
            _updateQuickReplies() {
                const content = this.displayedText.toLowerCase();
                let newReplies = [];
                
                if (content.includes('Áîü‰∫ß') || content.includes('ÁÆ°ÁêÜ')) {
                    newReplies = app.messageManager.messageTemplates.farming;
                } else if (content.includes('ÂÖªÊÆñ') || content.includes('Âä®Áâ©')) {
                    newReplies = app.messageManager.messageTemplates.breeding;
                } else if (content.includes('Êï∞ÊçÆ') || content.includes('ÂàÜÊûê')) {
                    newReplies = app.messageManager.messageTemplates.data;
                } else {
                    return;
                }
                
                app.uiManager.renderQuickReplies(newReplies);
            }
            
            _generateId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
        }

        // ===== UIÁÆ°ÁêÜÂô® =====
        class UIManager {
            constructor() {
                this.apiSettingsOpen = false;
                this.elements = this._initializeElements();
                this._bindEvents();
            }

            _initializeElements() {
                return {
                    chatArea: document.getElementById('aiChatArea'),
                    input: document.getElementById('aiInput'),
                    sendButton: document.getElementById('sendButton'),
                    apiSettings: document.getElementById('apiSettings'),
                    quickReplies: document.getElementById('quickReplies')
                };
            }

            _bindEvents() {
                // ËæìÂÖ•Ê°Ü‰∫ã‰ª∂
                this.elements.input.addEventListener('input', (e) => this.autoResize(e.target));
                this.elements.input.addEventListener('keypress', (e) => this.handleKeyPress(e));
                
                // ÂèëÈÄÅÊåâÈíÆ‰∫ã‰ª∂
                this.elements.sendButton.addEventListener('click', () => {
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                });

                // ÂÖ®Â±ÄÈîÆÁõò‰∫ã‰ª∂
                document.addEventListener('keydown', (e) => this.handleGlobalKeyPress(e));
                
                // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠APIËÆæÁΩÆ
                document.addEventListener('click', (e) => this.handleOutsideClick(e));
            }

            handleKeyPress(event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                } else if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault();
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                }
            }

            handleGlobalKeyPress(event) {
                // Ctrl+K ËÅöÁÑ¶ËæìÂÖ•Ê°Ü
                if (event.ctrlKey && event.key === 'k') {
                    event.preventDefault();
                    this.elements.input.focus();
                    this.elements.input.select();
                }
                
                // Ctrl+L Ê∏ÖÁ©∫ÂØπËØù
                if (event.ctrlKey && event.key === 'l') {
                    event.preventDefault();
                    if (confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂØπËØùÂêóÔºü')) {
                        app.messageManager.clearMessages();
                    }
                }
                
                // Escape ÈîÆÂ§ÑÁêÜ
                if (event.key === 'Escape') {
                    if (app.isStreaming && app.apiClient.currentController) {
                        app.apiClient.abort();
                        app.notificationManager.show('ÂØπËØùÂ∑≤ÂèñÊ∂à', 'info');
                    } else if (this.apiSettingsOpen) {
                        this.closeAPISettings();
                    }
                }
            }

            handleOutsideClick(event) {
                if (this.apiSettingsOpen && 
                    !this.elements.apiSettings.contains(event.target) && 
                    !event.target.closest('.settings-btn')) {
                    this.closeAPISettings();
                }
            }

            toggleAPISettings() {
                this.apiSettingsOpen ? this.closeAPISettings() : this.openAPISettings();
            }

            openAPISettings() {
                this.elements.apiSettings.classList.add('show');
                this.apiSettingsOpen = true;
            }

            closeAPISettings() {
                this.elements.apiSettings.classList.remove('show');
                this.apiSettingsOpen = false;
            }

            addMessageToUI(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message' + (message.role === 'user' ? ' user' : '');
                messageDiv.setAttribute('data-message-id', message.id);

                const timeStr = message.timestamp.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                if (message.role === 'user') {
                    messageDiv.innerHTML = `
                        <div class="message-avatar user">üë§</div>
                        <div>
                            <div class="message-content user">${message.content}</div>
                            <div class="message-time">${timeStr}</div>
                        </div>
                    `;
                } else {
                    messageDiv.innerHTML = `
                        <div class="message-avatar ai">üê∑</div>
                        <div>
                            <div class="message-content ai">${this.formatMessage(message.content)}</div>
                            <div class="message-time">${timeStr}</div>
                        </div>
                    `;
                }

                this.elements.chatArea.appendChild(messageDiv);
                this.scrollToBottom();
            }

            createStreamingMessage() {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';

                const timeStr = new Date().toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                messageDiv.innerHTML = `
                    <div class="message-avatar ai">üê∑</div>
                    <div>
                        <div class="message-content ai" id="streamingMessage"></div>
                        <div class="message-time">${timeStr}</div>
                    </div>
                `;

                this.elements.chatArea.appendChild(messageDiv);
                this.scrollToBottom();

                return document.getElementById('streamingMessage');
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'chat-message typing-message';
                typingDiv.innerHTML = `
                    <div class="message-avatar ai">üê∑</div>
                    <div>
                        <div class="typing-indicator">
                            <div class="typing-dots">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                            <span class="typing-text">Á•ûÂÜúÊôìÈóÆÊ≠£Âú®ÊÄùËÄÉ...</span>
                        </div>
                    </div>
                `;

                this.elements.chatArea.appendChild(typingDiv);
                this.scrollToBottom();
                return typingDiv;
            }

            hideTypingIndicator() {
                const typingMessage = document.querySelector('.typing-message');
                if (typingMessage) {
                    typingMessage.remove();
                }
            }

            showErrorMessage(errorMessage, retryCallback) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'chat-message error-message-container';
                errorDiv.innerHTML = `
                    <div class="message-avatar ai">üê∑</div>
                    <div>
                        <div class="message-error">
                            <div class="error-content">
                                <i class="fas fa-exclamation-triangle"></i>
                                <span>${errorMessage}</span>
                                <button class="retry-btn">
                                    <i class="fas fa-redo"></i> ÈáçËØï
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                const retryBtn = errorDiv.querySelector('.retry-btn');
                retryBtn.addEventListener('click', retryCallback);

                this.elements.chatArea.appendChild(errorDiv);
                this.scrollToBottom();
            }

            setStreamingState(isStreaming) {
                this.elements.sendButton.disabled = isStreaming;
                this.elements.sendButton.innerHTML = isStreaming ? 
                    '<i class="fas fa-spinner fa-spin"></i>' : 
                    '<i class="fas fa-paper-plane"></i>';
            }

            setInputValue(value) {
                this.elements.input.value = value;
                this.autoResize(this.elements.input);
            }

            clearInput() {
                this.elements.input.value = '';
                this.elements.input.style.height = 'auto';
            }

            autoResize(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }

            scrollToBottom() {
                this.elements.chatArea.scrollTop = this.elements.chatArea.scrollHeight;
            }

            formatMessage(text) {
                return text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px;">$1</code>')
                    .replace(/```([\s\S]*?)```/g, '<pre style="background: rgba(0,0,0,0.05); padding: 8px; border-radius: 6px; margin: 8px 0; overflow-x: auto;"><code>$1</code></pre>')
                    .replace(/\n/g, '<br>');
            }

            renderQuickReplies(replies) {
                if (!this.elements.quickReplies) return;

                this.elements.quickReplies.style.opacity = '0';
                setTimeout(() => {
                    this.elements.quickReplies.innerHTML = '';
                    replies.forEach((reply, index) => {
                        const button = document.createElement('div');
                        button.className = 'quick-reply';
                        button.textContent = reply;
                        button.style.animationDelay = `${index * 0.1}s`;
                        button.onclick = () => app.messageManager.sendQuickReply(reply);
                        this.elements.quickReplies.appendChild(button);
                    });
                    this.elements.quickReplies.style.opacity = '1';
                }, 200);
            }
        }

        // ===== ÈÄöÁü•ÁÆ°ÁêÜÂô® =====
        class NotificationManager {
            constructor() {
                this.notifications = [];
                this.maxNotifications = 3;
            }

            show(message, type = 'info', duration = 3000) {
                const notification = this._createNotification(message, type);
                document.body.appendChild(notification);
                
                this.notifications.push(notification);
                this._limitNotifications();

                // ÊòæÁ§∫Âä®Áîª
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateX(0)';
                }, 10);

                // Ëá™Âä®ÈöêËóè
                setTimeout(() => {
                    this.hide(notification);
                }, duration);

                return notification;
            }

            hide(notification) {
                if (notification && notification.parentNode) {
                    notification.style.animation = 'slideOutNotification 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                        this._removeFromArray(notification);
                    }, 300);
                }
            }

            _createNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                notification.style.transition = 'all 0.3s ease';
                
                const icon = this._getIcon(type);
                notification.innerHTML = `
                    <i class="fas ${icon}"></i>
                    <span>${message}</span>
                `;

                // ÁÇπÂáªÂÖ≥Èó≠
                notification.addEventListener('click', () => {
                    this.hide(notification);
                });

                return notification;
            }

            _getIcon(type) {
                const icons = {
                    success: 'fa-check-circle',
                    error: 'fa-times-circle',
                    warning: 'fa-exclamation-triangle',
                    info: 'fa-info-circle'
                };
                return icons[type] || icons.info;
            }

            _limitNotifications() {
                while (this.notifications.length > this.maxNotifications) {
                    const oldest = this.notifications.shift();
                    this.hide(oldest);
                }
            }

            _removeFromArray(notification) {
                this.notifications = this.notifications.filter(n => n !== notification);
            }
        }

        // ===== ‰∫ã‰ª∂ÁÆ°ÁêÜÂô® =====
        class EventManager {
            constructor() {
                this.listeners = new Map();
                this._initializeGlobalEvents();
            }

            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            }

            off(event, callback) {
                if (this.listeners.has(event)) {
                    const callbacks = this.listeners.get(event);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            }

            emit(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`‰∫ã‰ª∂ÁõëÂê¨Âô®ÊâßË°åÈîôËØØ [${event}]:`, error);
                        }
                    });
                }
            }

            _initializeGlobalEvents() {
                // È°µÈù¢Âç∏ËΩΩÊó∂Ê∏ÖÁêÜËµÑÊ∫ê
                window.addEventListener('beforeunload', () => {
                    this.emit('app:beforeUnload');
                });

                // Á™óÂè£Â§ßÂ∞èÊîπÂèò
                window.addEventListener('resize', this._debounce(() => {
                    this.emit('app:resize', {
                        width: window.innerWidth,
                        height: window.innerHeight
                    });
                }, 250));

                // Âú®Á∫ø/Á¶ªÁ∫øÁä∂ÊÄÅ
                window.addEventListener('online', () => {
                    this.emit('app:online');
                });

                window.addEventListener('offline', () => {
                    this.emit('app:offline');
                });

                // Á™óÂè£Ê∂àÊÅØÔºàÁî®‰∫éiframeÈÄö‰ø°Ôºâ
                window.addEventListener('message', (event) => {
                    this.emit('app:message', event.data);
                });
            }

            _debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // ===== ‰∏ªÂ∫îÁî®Á±ª =====
        class AIChat {
            constructor() {
                this.isStreaming = false;
                this.currentStreamHandler = null;
                
                // ÂàùÂßãÂåñÁÆ°ÁêÜÂô®
                this.configManager = new ConfigManager();
                this.apiClient = new APIClient(this.configManager);
                this.messageManager = new MessageManager(this.apiClient);
                this.uiManager = new UIManager();
                this.notificationManager = new NotificationManager();
                this.eventManager = new EventManager();

                this._bindManagerEvents();
                this._initialize();
            }

            _bindManagerEvents() {
                // ÈÖçÁΩÆÂèòÊõ¥‰∫ã‰ª∂
                this.configManager.addObserver(this);

                // Ê∂àÊÅØ‰∫ã‰ª∂
                this.messageManager.addObserver(this);

                // Â∫îÁî®Á∫ß‰∫ã‰ª∂
                this.eventManager.on('app:beforeUnload', () => {
                    if (this.apiClient.currentController) {
                        this.apiClient.abort();
                    }
                });

                this.eventManager.on('app:online', () => {
                    this.notificationManager.show('ÁΩëÁªúËøûÊé•Â∑≤ÊÅ¢Â§ç', 'success');
                });

                this.eventManager.on('app:offline', () => {
                    this.notificationManager.show('ÁΩëÁªúËøûÊé•Â∑≤Êñ≠ÂºÄ', 'warning');
                });

                this.eventManager.on('app:message', (data) => {
                    if (data.type === 'switchMode') {
                        this._handleModeSwitch(data.mode);
                    }
                });
            }

            _initialize() {
                this._detectEnvironment();
                
                // Âª∂ËøüËÅöÁÑ¶ËæìÂÖ•Ê°Ü
                setTimeout(() => {
                    this.uiManager.elements.input.focus();
                    this.uiManager.autoResize(this.uiManager.elements.input);
                }, 100);

                console.log('AIÂØπËØù‰ΩìÈ™å‰ºòÂåñÂ∑≤Âä†ËΩΩ - Ê®°ÂùóÂåñÊû∂ÊûÑÁâàÊú¨');
            }

            _detectEnvironment() {
                try {
                    if (window.self !== window.top) {
                        document.body.classList.add('embedded');
                        console.log('AIÊ®°ÂùóËøêË°åÂú®iframe‰∏≠');
                    }
                    
                    if (window.parent && window.parent !== window) {
                        const parentDoc = window.parent.document;
                        if (parentDoc.querySelector('.ai-sidebar.fullscreen')) {
                            document.body.classList.add('fullscreen');
                            console.log('AIÊ®°ÂùóËøêË°åÂú®ÂÖ®Â±èÊ®°Âºè');
                        }
                    }
                } catch (e) {
                    console.log('AIÊ®°ÂùóËøêË°åÂú®Áã¨Á´ãÁ™óÂè£‰∏≠');
                }
            }

            _handleModeSwitch(mode) {
                if (mode === 'fullscreen') {
                    document.body.classList.add('fullscreen');
                } else {
                    document.body.classList.remove('fullscreen');
                }
            }

            // ÈÖçÁΩÆÁÆ°ÁêÜÂô®ËßÇÂØüËÄÖÊñπÊ≥ï
            onConfigChange(change) {
                console.log('ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞:', change);
                this.eventManager.emit('config:changed', change);
            }

            // Ê∂àÊÅØÁÆ°ÁêÜÂô®ËßÇÂØüËÄÖÊñπÊ≥ï
            onMessageEvent(event) {
                console.log('Ê∂àÊÅØ‰∫ã‰ª∂:', event);
                this.eventManager.emit('message:event', event);
            }

            // ÂÖ¨ÂÖ±APIÊñπÊ≥ï
            sendMessage(content) {
                return this.messageManager.sendMessage(content);
            }

            clearChat() {
                return this.messageManager.clearMessages();
            }

            exportChat(format = 'json') {
                return this.messageManager.exportMessages(format);
            }

            searchMessages(query) {
                return this.messageManager.searchMessages(query);
            }

            updateConfig(updates) {
                return this.configManager.updateConfig(updates);
            }

            showNotification(message, type, duration) {
                return this.notificationManager.show(message, type, duration);
            }

            // Ëé∑ÂèñÂ∫îÁî®Áä∂ÊÄÅ
            getState() {
                return {
                    isStreaming: this.isStreaming,
                    messageCount: this.messageManager.messages.length,
                    config: this.configManager.getConfig(),
                    apiSettingsOpen: this.uiManager.apiSettingsOpen
                };
            }
        }

        // ===== ÂÖ®Â±ÄÂ∫îÁî®ÂÆû‰æã =====
        let app = null;

        // ===== È°µÈù¢ÂàùÂßãÂåñ =====
        document.addEventListener('DOMContentLoaded', function () {
            // ÂàõÂª∫Â∫îÁî®ÂÆû‰æã
            app = new AIChat();
            
            // Êö¥Èú≤Âà∞ÂÖ®Â±Ä‰ΩúÁî®Âüü‰ª•‰æøHTML‰∏≠ÁöÑonclickË∞ÉÁî®
            window.app = app;
            
            // Ê∑ªÂä†ÂÖ®Â±ÄÂø´Êç∑ÈîÆÊèêÁ§∫
            const shortcuts = [
                'Ctrl+K: ËÅöÁÑ¶ËæìÂÖ•Ê°Ü',
                'Ctrl+L: Ê∏ÖÁ©∫ÂØπËØù',
                'Ctrl+Enter: ÂèëÈÄÅÊ∂àÊÅØ',
                'ESC: ÂèñÊ∂àÂΩìÂâçÊìç‰Ωú'
            ];
            
            console.log('ÂèØÁî®Âø´Êç∑ÈîÆ:', shortcuts.join(', '));
        });

        // ===== ÂÖºÂÆπÊÄßÊîØÊåÅÂáΩÊï∞ =====
        // ‰∏∫‰∫Ü‰øùÊåÅ‰∏éÂéüHTML onclickÁöÑÂÖºÂÆπÊÄßÔºå‰øùÁïô‰∏Ä‰∫õÂÖ®Â±ÄÂáΩÊï∞
        function toggleAPISettings() {
            if (app) app.uiManager.toggleAPISettings();
        }

        function sendQuickReply(message) {
            if (app) app.messageManager.sendQuickReply(message);
        }

        function handleAIKeyPress(event) {
            if (app) app.uiManager.handleKeyPress(event);
        }

        function autoResize(textarea) {
            if (app) app.uiManager.autoResize(textarea);
        }

        function sendAIMessage() {
            if (app) {
                const message = app.uiManager.elements.input.value.trim();
                if (message) {
                    app.messageManager.sendMessage(message);
                    app.uiManager.clearInput();
                }
            }
        }
    </script>
</body>
</html>