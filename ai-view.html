<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI智能助手</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            background: transparent;
            min-height: 100vh;
            color: #333;
            display: flex;
            flex-direction: column;
        }

        .ai-chat-module {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            background: transparent;
        }

        .ai-chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            background: transparent;
        }

        .chat-message {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            animation: messageSlide 0.3s ease;
            position: relative;
        }

        .chat-message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .message-avatar.ai {
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
        }

        .message-avatar.user {
            background: linear-gradient(135deg, #4A90E2, #2563eb);
            color: white;
        }

        .message-content {
            max-width: 280px;
            padding: 12px 16px;
            border-radius: 18px;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
            position: relative;
        }

        .message-content.ai {
            background: rgba(249, 250, 251, 0.8);
            color: #374151;
            border-top-left-radius: 6px;
        }

        .message-content.user {
            background: linear-gradient(135deg, #4A90E2, #2563eb);
            color: white;
            border-top-right-radius: 6px;
        }

        .message-time {
            font-size: 11px;
            color: #9ca3af;
            margin-top: 4px;
            text-align: center;
        }

        .message-actions {
            display: none;
            position: absolute;
            top: -8px;
            right: -8px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            gap: 4px;
        }

        .chat-message:hover .message-actions {
            display: flex;
        }

        .action-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6b7280;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .action-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .typing-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(249, 250, 251, 0.8);
            border-radius: 18px;
            border-top-left-radius: 6px;
            max-width: 280px;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 6px;
            height: 6px;
            background: #9ca3af;
            border-radius: 50%;
            animation: typingDot 1.4s infinite;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        .typing-text {
            font-size: 12px;
            color: #6b7280;
        }

        .message-complete {
            color: #10b981;
            font-size: 12px;
            opacity: 0;
            animation: fadeIn 0.3s ease forwards;
        }

        .message-error {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.2);
            border-radius: 12px;
            padding: 12px 16px;
            margin: 10px 0;
            max-width: 280px;
        }

        .error-content {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #dc2626;
        }

        .retry-btn {
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
            transition: all 0.2s ease;
        }

        .retry-btn:hover {
            background: #b91c1c;
        }

        .ai-input-area {
            padding: 16px 20px 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
        }

        .quick-replies {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .quick-reply {
            padding: 6px 12px;
            background: rgba(255, 20, 147, 0.1);
            border: 1px solid rgba(255, 20, 147, 0.2);
            border-radius: 16px;
            font-size: 12px;
            color: #FF1493;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0;
            transform: translateY(10px);
            animation: quickReplySlide 0.3s ease forwards;
        }

        .quick-reply:nth-child(1) { animation-delay: 0.1s; }
        .quick-reply:nth-child(2) { animation-delay: 0.2s; }
        .quick-reply:nth-child(3) { animation-delay: 0.3s; }
        .quick-reply:nth-child(4) { animation-delay: 0.4s; }

        .quick-reply:hover {
            background: rgba(255, 20, 147, 0.2);
            transform: translateY(-1px);
        }

        .input-container {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .ai-input {
            flex: 1;
            min-height: 40px;
            max-height: 120px;
            padding: 10px 16px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: all 0.2s ease;
            font-family: inherit;
            background: rgba(255, 255, 255, 0.9);
        }

        .ai-input:focus {
            border-color: #FF1493;
            box-shadow: 0 0 0 3px rgba(255, 20, 147, 0.1);
        }

        .send-button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: white;
            font-size: 16px;
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(255, 20, 147, 0.4);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .api-settings {
            position: absolute;
            top: 10px;
            right: 20px;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 16px;
            width: 280px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            z-index: 1002;
            transform: scale(0.95) translateY(-10px);
            opacity: 0;
            transition: all 0.2s ease;
            pointer-events: none;
        }

        .api-settings.show {
            transform: scale(1) translateY(0);
            opacity: 1;
            pointer-events: auto;
        }

        .api-settings h4 {
            margin-bottom: 12px;
            color: #2E3A59;
            font-size: 16px;
        }

        .api-settings label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #4b5563;
            font-weight: 500;
        }

        .api-settings input,
        .api-settings select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            transition: all 0.2s ease;
        }

        .api-settings input:focus,
        .api-settings select:focus {
            outline: none;
            border-color: #FF1493;
            box-shadow: 0 0 0 2px rgba(255, 20, 147, 0.1);
        }

        .api-settings button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .api-settings button:hover {
            background: linear-gradient(135deg, #FF1493, #DC143C);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 20, 147, 0.3);
        }

        .settings-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.05);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            color: #6b7280;
            font-size: 14px;
            z-index: 1001;
        }

        .settings-btn:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 10000;
            animation: slideInNotification 0.3s ease;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            max-width: 300px;
        }

        .notification.success { background: #10b981; color: white; }
        .notification.error { background: #ef4444; color: white; }
        .notification.warning { background: #f59e0b; color: white; }
        .notification.info { background: #3b82f6; color: white; }

        /* 动画定义 */
        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes quickReplySlide {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes typingDot {
            0%, 60%, 100% {
                opacity: 0.4;
                transform: scale(1);
            }
            30% {
                opacity: 1;
                transform: scale(1.2);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes slideInNotification {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOutNotification {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* 响应式适配 */
        @media (max-width: 400px) {
            .ai-chat-area {
                padding: 15px;
            }

            .ai-input-area {
                padding: 16px 15px 20px;
            }

            .message-content {
                max-width: 240px;
            }

            .api-settings {
                right: 10px;
                left: 10px;
                width: auto;
            }
        }
    </style>
</head>
<body class="embedded">
    <!-- API设置按钮 -->
    <button class="settings-btn" onclick="app.uiManager.toggleAPISettings()" title="API设置">
        <i class="fas fa-cog"></i>
    </button>

    <!-- API设置面板 -->
    <div class="api-settings" id="apiSettings">
        <h4>API 配置</h4>
        <label for="apiKey">API Key</label>
        <input type="password" id="apiKey" placeholder="请输入您的API Key">

        <label for="modelSelect">模型选择</label>
        <select id="modelSelect">
            <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
            <option value="gpt-4">GPT-4</option>
            <option value="gpt-4-turbo">GPT-4 Turbo</option>
            <option value="llama2">Llama 2</option>
            <option value="claude-3">Claude 3</option>
        </select>

        <label for="maxTokens">最大令牌数</label>
        <input type="number" id="maxTokens" value="2000" min="100" max="4000">

        <label for="temperature">创造性 (0-1)</label>
        <input type="number" id="temperature" value="0.7" min="0" max="1" step="0.1">

        <button onclick="app.configManager.saveSettings()">保存设置</button>
    </div>

    <div class="ai-chat-module">
        <div class="ai-chat-area" id="aiChatArea">
            <div class="chat-message">
                <div class="message-avatar ai">🐷</div>
                <div>
                    <div class="message-content ai">
                        您好！我是神农晓问，您的专属智能农牧助手！🐷✨<br><br>
                        请先在设置中配置API Key，然后我就能为您提供专业的农牧业咨询服务了！
                    </div>
                    <div class="message-time">刚刚</div>
                </div>
            </div>
        </div>

        <div class="ai-input-area">
            <div class="quick-replies" id="quickReplies">
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('生产管理系统怎么使用？')">生产管理</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('智慧养殖有哪些功能？')">智慧养殖</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('如何进行数据分析？')">数据分析</div>
                <div class="quick-reply" onclick="app.messageManager.sendQuickReply('系统操作帮助')">系统帮助</div>
            </div>
            <div class="input-container">
                <textarea class="ai-input"
                          id="aiInput"
                          placeholder="输入您的问题..."
                          rows="1"></textarea>
                <button class="send-button" id="sendButton">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <script>
        // ===== 核心配置管理器 =====
        class ConfigManager {
            constructor() {
                this.config = {
                    baseURL: 'http://3.0.76.119:3000/api',
                    apiKey: '',
                    model: 'snDr-1.0-turbo',
                    maxTokens: 2000,
                    temperature: 0.7
                };
                this.observers = [];
                this.loadSettings();
            }

            addObserver(observer) {
                this.observers.push(observer);
            }

            removeObserver(observer) {
                this.observers = this.observers.filter(obs => obs !== observer);
            }

            notifyObservers(change) {
                this.observers.forEach(observer => {
                    if (typeof observer.onConfigChange === 'function') {
                        observer.onConfigChange(change);
                    }
                });
            }

            updateConfig(updates) {
                const oldConfig = { ...this.config };
                this.config = { ...this.config, ...updates };
                
                this.notifyObservers({
                    type: 'config_updated',
                    oldConfig,
                    newConfig: this.config,
                    changes: updates
                });
            }

            validateApiKey(apiKey) {
                if (!apiKey || apiKey.length < 10) {
                    throw new Error('API Key长度过短，请检查是否完整');
                }
                
                // 检查非ASCII字符
                const cleanApiKey = apiKey.replace(/[^\x00-\x7F]/g, '');
                if (apiKey !== cleanApiKey) {
                    throw new Error('API Key包含无效字符，请使用纯英文字符');
                }
                
                return cleanApiKey;
            }

            saveSettings() {
                try {
                    const apiKey = document.getElementById('apiKey').value.trim();
                    const model = document.getElementById('modelSelect').value;
                    const maxTokens = parseInt(document.getElementById('maxTokens').value);
                    const temperature = parseFloat(document.getElementById('temperature').value);

                    if (apiKey) {
                        this.validateApiKey(apiKey);
                    }

                    this.updateConfig({
                        apiKey,
                        model,
                        maxTokens,
                        temperature
                    });

                    localStorage.setItem('aiConfig', JSON.stringify(this.config));
                    
                    app.uiManager.closeAPISettings();
                    app.notificationManager.show(
                        apiKey ? 'API设置已保存！可以开始对话了' : 'API设置已保存，但需要配置有效的API Key',
                        apiKey ? 'success' : 'warning'
                    );
                } catch (error) {
                    app.notificationManager.show(error.message, 'error');
                }
            }

            loadSettings() {
                try {
                    const saved = localStorage.getItem('aiConfig');
                    if (saved) {
                        const config = JSON.parse(saved);
                        this.config = { ...this.config, ...config };
                        this.updateUIWithConfig();
                    }
                } catch (error) {
                    console.error('加载API设置失败:', error);
                }
            }

            updateUIWithConfig() {
                const elements = {
                    'apiKey': this.config.apiKey,
                    'modelSelect': this.config.model,
                    'maxTokens': this.config.maxTokens,
                    'temperature': this.config.temperature
                };

                Object.entries(elements).forEach(([id, value]) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.value = value;
                    }
                });
            }

            getConfig() {
                return { ...this.config };
            }
        }

        // ===== API客户端管理器 =====
        class APIClient {
            constructor(configManager) {
                this.configManager = configManager;
                this.currentController = null;
                this.retryCount = 0;
                this.maxRetries = 3;
                this.baseDelay = 1000; // 基础延迟1秒
            }

            async sendMessage(messages, onChunk, onComplete, onError) {
                const config = this.configManager.getConfig();
                
                if (!config.apiKey) {
                    throw new Error('请先配置API Key');
                }

                this.currentController = new AbortController();
                this.retryCount = 0;

                try {
                    await this._sendWithRetry(messages, onChunk, onComplete, onError);
                } catch (error) {
                    if (error.name !== 'AbortError') {
                        onError(error);
                    }
                }
            }

            async _sendWithRetry(messages, onChunk, onComplete, onError) {
                const config = this.configManager.getConfig();
                
                try {
                    const response = await this._makeRequest(messages, config);
                    await this._handleStreamResponse(response, onChunk, onComplete);
                } catch (error) {
                    if (this.shouldRetry(error) && this.retryCount < this.maxRetries) {
                        this.retryCount++;
                        const delay = this.baseDelay * Math.pow(2, this.retryCount - 1); // 指数退避
                        
                        app.notificationManager.show(
                            `请求失败，${delay / 1000}秒后重试 (${this.retryCount}/${this.maxRetries})`,
                            'warning'
                        );
                        
                        await this._delay(delay);
                        return this._sendWithRetry(messages, onChunk, onComplete, onError);
                    }
                    throw error;
                }
            }

            async _makeRequest(messages, config) {
                const requestHeaders = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${config.apiKey}`
                };

                const requestBody = {
                    model: '-',
                    messages,
                    max_tokens: config.maxTokens,
                    temperature: config.temperature,
                    stream: true
                };

                const response = await fetch(`${config.baseURL}/chat/completions`, {
                    method: 'POST',
                    headers: requestHeaders,
                    body: JSON.stringify(requestBody),
                    signal: this.currentController.signal
                });

                if (!response.ok) {
                    throw this._createErrorFromResponse(response);
                }

                return response;
            }

            async _handleStreamResponse(response, onChunk, onComplete) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let fullResponse = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6).trim();
                            if (data === '[DONE]') {
                                onComplete(fullResponse);
                                return;
                            }

                            if (data) {
                                try {
                                    const parsed = JSON.parse(data);
                                    const content = parsed.choices?.[0]?.delta?.content;

                                    if (content) {
                                        fullResponse += content;
                                        onChunk(content);
                                    }
                                } catch (parseError) {
                                    console.warn('解析SSE数据失败:', parseError);
                                    continue;
                                }
                            }
                        }
                    }
                }

                onComplete(fullResponse);
            }

            _createErrorFromResponse(response) {
                let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                
                switch (response.status) {
                    case 401:
                        errorMessage = '认证失败，请检查API Key是否正确';
                        break;
                    case 403:
                        errorMessage = '访问被拒绝，API Key可能没有权限';
                        break;
                    case 404:
                        errorMessage = '服务器端点不存在，请检查服务器地址';
                        break;
                    case 429:
                        errorMessage = '请求过于频繁，请稍后再试';
                        break;
                    case 500:
                        errorMessage = '服务器内部错误，请稍后重试';
                        break;
                }

                return new Error(errorMessage);
            }

            shouldRetry(error) {
                if (error.name === 'AbortError') return false;
                
                const retryableErrors = [500, 502, 503, 504, 429];
                const statusMatch = error.message.match(/HTTP (\d+):/);
                
                if (statusMatch) {
                    const status = parseInt(statusMatch[1]);
                    return retryableErrors.includes(status);
                }
                
                return error.message.includes('网络') || 
               error.message.includes('timeout') ||
               error.message.includes('Failed to fetch');
            }

            _delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            abort() {
                if (this.currentController) {
                    this.currentController.abort();
                    this.currentController = null;
                }
            }
        }

        // ===== 消息管理器 =====
        class MessageManager {
            constructor(apiClient) {
                this.apiClient = apiClient;
                this.messages = [];
                this.maxHistory = 10;
                this.contextWindow = 4000;
                this.messageTemplates = this._initializeTemplates();
                this.observers = [];
            }

            addObserver(observer) {
                this.observers.push(observer);
            }

            notifyObservers(event) {
                this.observers.forEach(observer => {
                    if (typeof observer.onMessageEvent === 'function') {
                        observer.onMessageEvent(event);
                    }
                });
            }

            addMessage(role, content) {
                const message = {
                    id: this._generateId(),
                    role,
                    content,
                    timestamp: new Date(),
                    tokens: this._estimateTokens(content)
                };

                this.messages.push(message);
                this._trimContext();
                
                this.notifyObservers({
                    type: 'message_added',
                    message
                });

                return message;
            }

            async sendMessage(content) {
                if (!content.trim() || app.isStreaming) return;

                const userMessage = this.addMessage('user', content);
                app.uiManager.addMessageToUI(userMessage);
                
                app.isStreaming = true;
                app.uiManager.setStreamingState(true);

                const typingIndicator = app.uiManager.showTypingIndicator();

                try {
                    const contextMessages = this._getContextForAPI();
                    let fullResponse = '';

                    await this.apiClient.sendMessage(
                        contextMessages,
                        (chunk) => {
                            if (!app.currentStreamHandler) {
                                app.uiManager.hideTypingIndicator();
                                const messageElement = app.uiManager.createStreamingMessage();
                                app.currentStreamHandler = new StreamHandler(messageElement);
                            }
                            app.currentStreamHandler.addChunk(chunk);
                        },
                        (response) => {
                            fullResponse = response;
                            const aiMessage = this.addMessage('assistant', response);
                            
                            if (app.currentStreamHandler) {
                                app.currentStreamHandler.finishTyping();
                                app.currentStreamHandler = null;
                            }
                        },
                        (error) => {
                            app.uiManager.hideTypingIndicator();
                            app.uiManager.showErrorMessage(error.message, () => {
                                this.retryLastMessage();
                            });
                        }
                    );

                } catch (error) {
                    app.uiManager.hideTypingIndicator();
                    app.uiManager.showErrorMessage(error.message, () => {
                        this.retryLastMessage();
                    });
                } finally {
                    app.isStreaming = false;
                    app.uiManager.setStreamingState(false);
                }
            }

            sendQuickReply(message) {
                app.uiManager.setInputValue(message);
                this.sendMessage(message);
            }

            retryLastMessage() {
                const errorMessages = document.querySelectorAll('.error-message-container');
                errorMessages.forEach(msg => msg.remove());

                const lastUserMessage = this.messages[this.messages.length - 1];
                if (lastUserMessage && lastUserMessage.role === 'user') {
                    this.messages.pop();
                    this.sendMessage(lastUserMessage.content);
                }
            }

            copyMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"] .message-content`);
                if (messageElement) {
                    const text = messageElement.textContent || messageElement.innerText;
                    navigator.clipboard.writeText(text).then(() => {
                        app.notificationManager.show('消息已复制到剪贴板', 'success');
                    }).catch(() => {
                        app.notificationManager.show('复制失败', 'error');
                    });
                }
            }

            regenerateMessage(messageId) {
                const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                if (messageElement) {
                    // 移除后续的AI消息
                    let current = messageElement.nextElementSibling;
                    while (current) {
                        const next = current.nextElementSibling;
                        if (current.classList.contains('chat-message') && 
                            !current.classList.contains('user')) {
                            current.remove();
                        }
                        current = next;
                    }
                    
                    messageElement.remove();
                    
                    // 从消息历史中移除对应的消息
                    if (this.messages.length > 0) {
                        this.messages = this.messages.slice(0, -1);
                    }
                    
                    const lastUserMessage = this.messages[this.messages.length - 1];
                    if (lastUserMessage && lastUserMessage.role === 'user') {
                        this.sendMessage(lastUserMessage.content);
                    }
                }
            }

            likeMessage(messageId) {
                const likeBtn = document.querySelector(`[data-message-id="${messageId}"] .action-btn[onclick*="likeMessage"]`);
                if (likeBtn) {
                    likeBtn.style.color = '#10b981';
                    likeBtn.innerHTML = '<i class="fas fa-thumbs-up"></i>';
                    app.notificationManager.show('感谢您的反馈！', 'success');
                    this._recordMessageFeedback(messageId, 'like');
                }
            }

            searchMessages(query) {
                const results = [];
                for (const message of this.messages) {
                    if (message.content.toLowerCase().includes(query.toLowerCase())) {
                        results.push(message);
                    }
                }
                return results.sort((a, b) => b.timestamp - a.timestamp);
            }

            exportMessages(format = 'json') {
                const data = {
                    messages: this.messages,
                    exportTime: new Date().toISOString(),
                    totalMessages: this.messages.length
                };

                let content, filename, mimeType;

                switch (format) {
                    case 'json':
                        content = JSON.stringify(data, null, 2);
                        filename = `chat_export_${new Date().toISOString().split('T')[0]}.json`;
                        mimeType = 'application/json';
                        break;
                    case 'txt':
                        content = this.messages.map(msg => 
                            `[${msg.timestamp.toLocaleString()}] ${msg.role}: ${msg.content}`
                        ).join('\n\n');
                        filename = `chat_export_${new Date().toISOString().split('T')[0]}.txt`;
                        mimeType = 'text/plain';
                        break;
                    default:
                        throw new Error('不支持的导出格式');
                }

                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }

            clearMessages() {
                this.messages = [];
                const chatArea = document.getElementById('aiChatArea');
                if (chatArea) {
                    // 只保留欢迎消息
                    const welcomeMessage = chatArea.querySelector('.chat-message');
                    chatArea.innerHTML = '';
                    if (welcomeMessage) {
                        chatArea.appendChild(welcomeMessage);
                    }
                }
                
                this.notifyObservers({
                    type: 'messages_cleared'
                });
            }

            _trimContext() {
                let totalTokens = this.messages.reduce((sum, msg) => sum + msg.tokens, 0);
                
                while ((totalTokens > this.contextWindow || this.messages.length > this.maxHistory * 2) 
                       && this.messages.length > 2) {
                    const removed = this.messages.shift();
                    totalTokens -= removed.tokens;
                }
            }

            _getContextForAPI() {
                return [
                    {
                        role: 'system',
                        content: '你是神农集团的智能农牧助手"神农晓问"，专门为用户提供农牧业生产、管理、技术等方面的专业咨询和系统操作指导。请用中文回答，语气要友好专业。'
                    },
                    ...this.messages.map(msg => ({
                        role: msg.role,
                        content: msg.content
                    }))
                ];
            }

            _estimateTokens(text) {
                return Math.ceil(text.length / 1.5);
            }

            _generateId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            _initializeTemplates() {
                return {
                    farming: [
                        '如何查看生产报表？',
                        '生产计划怎么制定？',
                        '如何记录生产数据？',
                        '异常情况如何处理？'
                    ],
                    breeding: [
                        '如何监控动物健康？',
                        '环境参数设置指南',
                        '饲料配比建议',
                        '疫苗接种提醒'
                    ],
                    data: [
                        '如何导出数据？',
                        '报表生成步骤',
                        '数据异常处理',
                        '统计图表说明'
                    ]
                };
            }

            _recordMessageFeedback(messageId, type) {
                const feedback = {
                    messageId,
                    type,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent
                };
                
                const existingFeedback = JSON.parse(localStorage.getItem('messageFeedback') || '[]');
                existingFeedback.push(feedback);
                localStorage.setItem('messageFeedback', JSON.stringify(existingFeedback));
            }
        }

        // ===== 流式处理器 =====
        class StreamHandler {
            constructor(messageElement) {
                this.messageElement = messageElement;
                this.displayedText = '';
                this.pendingText = '';
                this.isTyping = false;
                this.typeSpeed = 20;
                this.messageId = this._generateId();
            }
            
            addChunk(chunk) {
                this.pendingText += chunk;
                if (!this.isTyping) {
                    this.startTypingEffect();
                }
            }
            
            startTypingEffect() {
                this.isTyping = true;
                this._typeNextChar();
            }
            
            _typeNextChar() {
                if (this.pendingText.length === 0) {
                    this.isTyping = false;
                    return;
                }
                
                const charsToAdd = Math.min(2, this.pendingText.length);
                const chars = this.pendingText.slice(0, charsToAdd);
                this.pendingText = this.pendingText.slice(charsToAdd);
                
                this.displayedText += chars;
                this.messageElement.innerHTML = app.uiManager.formatMessage(this.displayedText);
                
                app.uiManager.scrollToBottom();
                
                setTimeout(() => this._typeNextChar(), this.typeSpeed);
            }
            
            finishTyping() {
                if (this.pendingText.length > 0) {
                    this.displayedText += this.pendingText;
                    this.pendingText = '';
                    this.messageElement.innerHTML = app.uiManager.formatMessage(this.displayedText);
                    app.uiManager.scrollToBottom();
                }
                this.isTyping = false;
                this._onTypingComplete();
            }
            
            _onTypingComplete() {
                this._addMessageActions();
                this._addCompletionIndicator();
                this._updateQuickReplies();
            }
            
            _addMessageActions() {
                const messageContainer = this.messageElement.closest('.chat-message');
                if (messageContainer && !messageContainer.querySelector('.message-actions')) {
                    const actions = document.createElement('div');
                    actions.className = 'message-actions';
                    actions.innerHTML = `
                        <button class="action-btn" title="复制消息" onclick="app.messageManager.copyMessage('${this.messageId}')">
                            <i class="fas fa-copy"></i>
                        </button>
                        <button class="action-btn" title="重新生成" onclick="app.messageManager.regenerateMessage('${this.messageId}')">
                            <i class="fas fa-redo"></i>
                        </button>
                        <button class="action-btn" title="点赞" onclick="app.messageManager.likeMessage('${this.messageId}')">
                            <i class="fas fa-thumbs-up"></i>
                        </button>
                    `;
                    messageContainer.appendChild(actions);
                    messageContainer.setAttribute('data-message-id', this.messageId);
                }
            }
            
            _addCompletionIndicator() {
                if (!this.messageElement.querySelector('.message-complete')) {
                    const indicator = document.createElement('span');
                    indicator.className = 'message-complete';
                    indicator.innerHTML = ' ✓';
                    this.messageElement.appendChild(indicator);
                }
            }
            
            _updateQuickReplies() {
                const content = this.displayedText.toLowerCase();
                let newReplies = [];
                
                if (content.includes('生产') || content.includes('管理')) {
                    newReplies = app.messageManager.messageTemplates.farming;
                } else if (content.includes('养殖') || content.includes('动物')) {
                    newReplies = app.messageManager.messageTemplates.breeding;
                } else if (content.includes('数据') || content.includes('分析')) {
                    newReplies = app.messageManager.messageTemplates.data;
                } else {
                    return;
                }
                
                app.uiManager.renderQuickReplies(newReplies);
            }
            
            _generateId() {
                return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }
        }

        // ===== UI管理器 =====
        class UIManager {
            constructor() {
                this.apiSettingsOpen = false;
                this.elements = this._initializeElements();
                this._bindEvents();
            }

            _initializeElements() {
                return {
                    chatArea: document.getElementById('aiChatArea'),
                    input: document.getElementById('aiInput'),
                    sendButton: document.getElementById('sendButton'),
                    apiSettings: document.getElementById('apiSettings'),
                    quickReplies: document.getElementById('quickReplies')
                };
            }

            _bindEvents() {
                // 输入框事件
                this.elements.input.addEventListener('input', (e) => this.autoResize(e.target));
                this.elements.input.addEventListener('keypress', (e) => this.handleKeyPress(e));
                
                // 发送按钮事件
                this.elements.sendButton.addEventListener('click', () => {
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                });

                // 全局键盘事件
                document.addEventListener('keydown', (e) => this.handleGlobalKeyPress(e));
                
                // 点击外部关闭API设置
                document.addEventListener('click', (e) => this.handleOutsideClick(e));
            }

            handleKeyPress(event) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                } else if (event.ctrlKey && event.key === 'Enter') {
                    event.preventDefault();
                    const message = this.elements.input.value.trim();
                    if (message) {
                        app.messageManager.sendMessage(message);
                        this.clearInput();
                    }
                }
            }

            handleGlobalKeyPress(event) {
                // Ctrl+K 聚焦输入框
                if (event.ctrlKey && event.key === 'k') {
                    event.preventDefault();
                    this.elements.input.focus();
                    this.elements.input.select();
                }
                
                // Ctrl+L 清空对话
                if (event.ctrlKey && event.key === 'l') {
                    event.preventDefault();
                    if (confirm('确定要清空所有对话吗？')) {
                        app.messageManager.clearMessages();
                    }
                }
                
                // Escape 键处理
                if (event.key === 'Escape') {
                    if (app.isStreaming && app.apiClient.currentController) {
                        app.apiClient.abort();
                        app.notificationManager.show('对话已取消', 'info');
                    } else if (this.apiSettingsOpen) {
                        this.closeAPISettings();
                    }
                }
            }

            handleOutsideClick(event) {
                if (this.apiSettingsOpen && 
                    !this.elements.apiSettings.contains(event.target) && 
                    !event.target.closest('.settings-btn')) {
                    this.closeAPISettings();
                }
            }

            toggleAPISettings() {
                this.apiSettingsOpen ? this.closeAPISettings() : this.openAPISettings();
            }

            openAPISettings() {
                this.elements.apiSettings.classList.add('show');
                this.apiSettingsOpen = true;
            }

            closeAPISettings() {
                this.elements.apiSettings.classList.remove('show');
                this.apiSettingsOpen = false;
            }

            addMessageToUI(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message' + (message.role === 'user' ? ' user' : '');
                messageDiv.setAttribute('data-message-id', message.id);

                const timeStr = message.timestamp.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                if (message.role === 'user') {
                    messageDiv.innerHTML = `
                        <div class="message-avatar user">👤</div>
                        <div>
                            <div class="message-content user">${message.content}</div>
                            <div class="message-time">${timeStr}</div>
                        </div>
                    `;
                } else {
                    messageDiv.innerHTML = `
                        <div class="message-avatar ai">🐷</div>
                        <div>
                            <div class="message-content ai">${this.formatMessage(message.content)}</div>
                            <div class="message-time">${timeStr}</div>
                        </div>
                    `;
                }

                this.elements.chatArea.appendChild(messageDiv);
                this.scrollToBottom();
            }

            createStreamingMessage() {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'chat-message';

                const timeStr = new Date().toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                messageDiv.innerHTML = `
                    <div class="message-avatar ai">🐷</div>
                    <div>
                        <div class="message-content ai" id="streamingMessage"></div>
                        <div class="message-time">${timeStr}</div>
                    </div>
                `;

                this.elements.chatArea.appendChild(messageDiv);
                this.scrollToBottom();

                return document.getElementById('streamingMessage');
            }

            showTypingIndicator() {
                const typingDiv = document.createElement('div');
                typingDiv.className = 'chat-message typing-message';
                typingDiv.innerHTML = `
                    <div class="message-avatar ai">🐷</div>
                    <div>
                        <div class="typing-indicator">
                            <div class="typing-dots">
                                <span></span>
                                <span></span>
                                <span></span>
                            </div>
                            <span class="typing-text">神农晓问正在思考...</span>
                        </div>
                    </div>
                `;

                this.elements.chatArea.appendChild(typingDiv);
                this.scrollToBottom();
                return typingDiv;
            }

            hideTypingIndicator() {
                const typingMessage = document.querySelector('.typing-message');
                if (typingMessage) {
                    typingMessage.remove();
                }
            }

            showErrorMessage(errorMessage, retryCallback) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'chat-message error-message-container';
                errorDiv.innerHTML = `
                    <div class="message-avatar ai">🐷</div>
                    <div>
                        <div class="message-error">
                            <div class="error-content">
                                <i class="fas fa-exclamation-triangle"></i>
                                <span>${errorMessage}</span>
                                <button class="retry-btn">
                                    <i class="fas fa-redo"></i> 重试
                                </button>
                            </div>
                        </div>
                    </div>
                `;

                const retryBtn = errorDiv.querySelector('.retry-btn');
                retryBtn.addEventListener('click', retryCallback);

                this.elements.chatArea.appendChild(errorDiv);
                this.scrollToBottom();
            }

            setStreamingState(isStreaming) {
                this.elements.sendButton.disabled = isStreaming;
                this.elements.sendButton.innerHTML = isStreaming ? 
                    '<i class="fas fa-spinner fa-spin"></i>' : 
                    '<i class="fas fa-paper-plane"></i>';
            }

            setInputValue(value) {
                this.elements.input.value = value;
                this.autoResize(this.elements.input);
            }

            clearInput() {
                this.elements.input.value = '';
                this.elements.input.style.height = 'auto';
            }

            autoResize(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
            }

            scrollToBottom() {
                this.elements.chatArea.scrollTop = this.elements.chatArea.scrollHeight;
            }

            formatMessage(text) {
                return text
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code style="background: rgba(0,0,0,0.1); padding: 2px 4px; border-radius: 3px;">$1</code>')
                    .replace(/```([\s\S]*?)```/g, '<pre style="background: rgba(0,0,0,0.05); padding: 8px; border-radius: 6px; margin: 8px 0; overflow-x: auto;"><code>$1</code></pre>')
                    .replace(/\n/g, '<br>');
            }

            renderQuickReplies(replies) {
                if (!this.elements.quickReplies) return;

                this.elements.quickReplies.style.opacity = '0';
                setTimeout(() => {
                    this.elements.quickReplies.innerHTML = '';
                    replies.forEach((reply, index) => {
                        const button = document.createElement('div');
                        button.className = 'quick-reply';
                        button.textContent = reply;
                        button.style.animationDelay = `${index * 0.1}s`;
                        button.onclick = () => app.messageManager.sendQuickReply(reply);
                        this.elements.quickReplies.appendChild(button);
                    });
                    this.elements.quickReplies.style.opacity = '1';
                }, 200);
            }
        }

        // ===== 通知管理器 =====
        class NotificationManager {
            constructor() {
                this.notifications = [];
                this.maxNotifications = 3;
            }

            show(message, type = 'info', duration = 3000) {
                const notification = this._createNotification(message, type);
                document.body.appendChild(notification);
                
                this.notifications.push(notification);
                this._limitNotifications();

                // 显示动画
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateX(0)';
                }, 10);

                // 自动隐藏
                setTimeout(() => {
                    this.hide(notification);
                }, duration);

                return notification;
            }

            hide(notification) {
                if (notification && notification.parentNode) {
                    notification.style.animation = 'slideOutNotification 0.3s ease';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                        this._removeFromArray(notification);
                    }, 300);
                }
            }

            _createNotification(message, type) {
                const notification = document.createElement('div');
                notification.className = `notification ${type}`;
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                notification.style.transition = 'all 0.3s ease';
                
                const icon = this._getIcon(type);
                notification.innerHTML = `
                    <i class="fas ${icon}"></i>
                    <span>${message}</span>
                `;

                // 点击关闭
                notification.addEventListener('click', () => {
                    this.hide(notification);
                });

                return notification;
            }

            _getIcon(type) {
                const icons = {
                    success: 'fa-check-circle',
                    error: 'fa-times-circle',
                    warning: 'fa-exclamation-triangle',
                    info: 'fa-info-circle'
                };
                return icons[type] || icons.info;
            }

            _limitNotifications() {
                while (this.notifications.length > this.maxNotifications) {
                    const oldest = this.notifications.shift();
                    this.hide(oldest);
                }
            }

            _removeFromArray(notification) {
                this.notifications = this.notifications.filter(n => n !== notification);
            }
        }

        // ===== 事件管理器 =====
        class EventManager {
            constructor() {
                this.listeners = new Map();
                this._initializeGlobalEvents();
            }

            on(event, callback) {
                if (!this.listeners.has(event)) {
                    this.listeners.set(event, []);
                }
                this.listeners.get(event).push(callback);
            }

            off(event, callback) {
                if (this.listeners.has(event)) {
                    const callbacks = this.listeners.get(event);
                    const index = callbacks.indexOf(callback);
                    if (index > -1) {
                        callbacks.splice(index, 1);
                    }
                }
            }

            emit(event, data) {
                if (this.listeners.has(event)) {
                    this.listeners.get(event).forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error(`事件监听器执行错误 [${event}]:`, error);
                        }
                    });
                }
            }

            _initializeGlobalEvents() {
                // 页面卸载时清理资源
                window.addEventListener('beforeunload', () => {
                    this.emit('app:beforeUnload');
                });

                // 窗口大小改变
                window.addEventListener('resize', this._debounce(() => {
                    this.emit('app:resize', {
                        width: window.innerWidth,
                        height: window.innerHeight
                    });
                }, 250));

                // 在线/离线状态
                window.addEventListener('online', () => {
                    this.emit('app:online');
                });

                window.addEventListener('offline', () => {
                    this.emit('app:offline');
                });

                // 窗口消息（用于iframe通信）
                window.addEventListener('message', (event) => {
                    this.emit('app:message', event.data);
                });
            }

            _debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }
        }

        // ===== 主应用类 =====
        class AIChat {
            constructor() {
                this.isStreaming = false;
                this.currentStreamHandler = null;
                
                // 初始化管理器
                this.configManager = new ConfigManager();
                this.apiClient = new APIClient(this.configManager);
                this.messageManager = new MessageManager(this.apiClient);
                this.uiManager = new UIManager();
                this.notificationManager = new NotificationManager();
                this.eventManager = new EventManager();

                this._bindManagerEvents();
                this._initialize();
            }

            _bindManagerEvents() {
                // 配置变更事件
                this.configManager.addObserver(this);

                // 消息事件
                this.messageManager.addObserver(this);

                // 应用级事件
                this.eventManager.on('app:beforeUnload', () => {
                    if (this.apiClient.currentController) {
                        this.apiClient.abort();
                    }
                });

                this.eventManager.on('app:online', () => {
                    this.notificationManager.show('网络连接已恢复', 'success');
                });

                this.eventManager.on('app:offline', () => {
                    this.notificationManager.show('网络连接已断开', 'warning');
                });

                this.eventManager.on('app:message', (data) => {
                    if (data.type === 'switchMode') {
                        this._handleModeSwitch(data.mode);
                    }
                });
            }

            _initialize() {
                this._detectEnvironment();
                
                // 延迟聚焦输入框
                setTimeout(() => {
                    this.uiManager.elements.input.focus();
                    this.uiManager.autoResize(this.uiManager.elements.input);
                }, 100);

                console.log('AI对话体验优化已加载 - 模块化架构版本');
            }

            _detectEnvironment() {
                try {
                    if (window.self !== window.top) {
                        document.body.classList.add('embedded');
                        console.log('AI模块运行在iframe中');
                    }
                    
                    if (window.parent && window.parent !== window) {
                        const parentDoc = window.parent.document;
                        if (parentDoc.querySelector('.ai-sidebar.fullscreen')) {
                            document.body.classList.add('fullscreen');
                            console.log('AI模块运行在全屏模式');
                        }
                    }
                } catch (e) {
                    console.log('AI模块运行在独立窗口中');
                }
            }

            _handleModeSwitch(mode) {
                if (mode === 'fullscreen') {
                    document.body.classList.add('fullscreen');
                } else {
                    document.body.classList.remove('fullscreen');
                }
            }

            // 配置管理器观察者方法
            onConfigChange(change) {
                console.log('配置已更新:', change);
                this.eventManager.emit('config:changed', change);
            }

            // 消息管理器观察者方法
            onMessageEvent(event) {
                console.log('消息事件:', event);
                this.eventManager.emit('message:event', event);
            }

            // 公共API方法
            sendMessage(content) {
                return this.messageManager.sendMessage(content);
            }

            clearChat() {
                return this.messageManager.clearMessages();
            }

            exportChat(format = 'json') {
                return this.messageManager.exportMessages(format);
            }

            searchMessages(query) {
                return this.messageManager.searchMessages(query);
            }

            updateConfig(updates) {
                return this.configManager.updateConfig(updates);
            }

            showNotification(message, type, duration) {
                return this.notificationManager.show(message, type, duration);
            }

            // 获取应用状态
            getState() {
                return {
                    isStreaming: this.isStreaming,
                    messageCount: this.messageManager.messages.length,
                    config: this.configManager.getConfig(),
                    apiSettingsOpen: this.uiManager.apiSettingsOpen
                };
            }
        }

        // ===== 全局应用实例 =====
        let app = null;

        // ===== 页面初始化 =====
        document.addEventListener('DOMContentLoaded', function () {
            // 创建应用实例
            app = new AIChat();
            
            // 暴露到全局作用域以便HTML中的onclick调用
            window.app = app;
            
            // 添加全局快捷键提示
            const shortcuts = [
                'Ctrl+K: 聚焦输入框',
                'Ctrl+L: 清空对话',
                'Ctrl+Enter: 发送消息',
                'ESC: 取消当前操作'
            ];
            
            console.log('可用快捷键:', shortcuts.join(', '));
        });

        // ===== 兼容性支持函数 =====
        // 为了保持与原HTML onclick的兼容性，保留一些全局函数
        function toggleAPISettings() {
            if (app) app.uiManager.toggleAPISettings();
        }

        function sendQuickReply(message) {
            if (app) app.messageManager.sendQuickReply(message);
        }

        function handleAIKeyPress(event) {
            if (app) app.uiManager.handleKeyPress(event);
        }

        function autoResize(textarea) {
            if (app) app.uiManager.autoResize(textarea);
        }

        function sendAIMessage() {
            if (app) {
                const message = app.uiManager.elements.input.value.trim();
                if (message) {
                    app.messageManager.sendMessage(message);
                    app.uiManager.clearInput();
                }
            }
        }
    </script>
</body>
</html>